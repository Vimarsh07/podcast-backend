# ======================== model.py ========================
from sqlalchemy import (
    Column, Integer, String, Text, ForeignKey, DateTime,
    UniqueConstraint, Index, Enum, text, BigInteger, Identity   # ← add BigInteger, Identity
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from datetime import datetime
from enum import Enum as PyEnum
from db import Base

class User(Base):
    __tablename__ = "users"
    __mapper_args__ = {"eager_defaults": True}  # fetch server defaults after INSERT

    id = Column(
        UUID(as_uuid=True),
        primary_key=True,
        server_default=text("gen_random_uuid()"),
        index=True,
    )

    # Tell SQLAlchemy this is server-generated (Postgres IDENTITY)
    user_int = Column(
        BigInteger,
        Identity(always=False),     # GENERATED BY DEFAULT AS IDENTITY
        unique=True,
        index=True,
        nullable=False,
    )

    email = Column(String, unique=True, nullable=False)
    password_hash = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    subscriptions = relationship("UserPodcast", back_populates="user", cascade="all, delete-orphan")

# ---------------- Enums ----------------
class TranscriptStatus(PyEnum):
    NOT_REQUESTED = "NOT_REQUESTED"
    QUEUED = "QUEUED"
    TRANSCRIBING = "TRANSCRIBING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class TranscriptOrigin(PyEnum):
    NONE = "NONE"
    ASR = "ASR"


# ---------------- Users ----------------


# ---------------- Podcasts ----------------
class Podcast(Base):
    __tablename__ = "podcasts"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    feed_url = Column(String, unique=True, nullable=False)
    title = Column(String)
    last_fetched = Column(DateTime)

    episodes = relationship(
        "Episode",
        back_populates="podcast",
        cascade="all, delete-orphan",
    )
    subscribers = relationship(
        "UserPodcast",
        back_populates="podcast",
        cascade="all, delete-orphan",
    )


# ---------------- User <-> Podcast (join) ----------------
class UserPodcast(Base):
    __tablename__ = "user_podcasts"

    user_id = Column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        primary_key=True,
    )
    podcast_id = Column(
        Integer,
        ForeignKey("podcasts.id", ondelete="CASCADE"),
        primary_key=True,
    )
    subscribed_at = Column(DateTime, default=datetime.utcnow)

    # Backrefs — names MUST match the properties above
    user = relationship("User", back_populates="subscriptions")
    podcast = relationship("Podcast", back_populates="subscribers")


# ---------------- Episodes ----------------
class Episode(Base):
    __tablename__ = "episodes"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    podcast_id = Column(Integer, ForeignKey("podcasts.id", ondelete="CASCADE"), nullable=False)

    # identity & metadata
    guid = Column(String, nullable=False)
    title = Column(String, nullable=True)
    pub_date = Column(DateTime, index=True)

    # summaries
    summary = Column(Text)            # plain text
    summary_html = Column(Text)       # raw HTML from RSS (optional)

    # extras
    duration_seconds = Column(Integer, nullable=True)
    image_url = Column(String, nullable=True)

    # audio
    audio_url = Column(String, nullable=True)

    # transcript pipeline
    transcript = Column(Text)         # ASR text only
    transcript_html = Column(Text)    # raw HTML from RSS if present (optional)
    transcript_origin = Column(
        Enum(TranscriptOrigin, name="transcript_origin_enum"),
        nullable=False,
        default=TranscriptOrigin.NONE,
        server_default="NONE",
    )
    transcript_status = Column(
        Enum(TranscriptStatus, name="transcript_status_enum"),
        nullable=False,
        default=TranscriptStatus.NOT_REQUESTED,
        server_default="NOT_REQUESTED",
    )

    __table_args__ = (
        UniqueConstraint("podcast_id", "guid", name="uq_episode"),
        Index("ix_episodes_podcast_pubdate", "podcast_id", "pub_date"),
    )

    podcast = relationship("Podcast", back_populates="episodes")
